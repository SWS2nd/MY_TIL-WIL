>금주의 계획 : 20일 월요일 ~ 22일 수요일 파이썬 게임 프로젝트 진행 / 23일 목요일 ~ 24일 금요일 카카오톡UI클론, 인스타UI클론 프로젝트 진행, 협업을 위한 GIT 활용 특강(오후2시~4시 예정) / 일주일 간 자료구조 알고리즘 강의 듣기, 웹 프로그래밍 A to Z 및 웹 타임어택 과제 복습

<br>

------------------------

<br>


어제와 동일하게 오전 9시 게더타운 대강당에서 금일 오후 4시 전까지 제출해야 하는 간단한 파이썬 게임 프로젝트에 대한 설명을 듣고 프로젝트를 진행하였다.

>[simple Explanation]
파이썬 게임 2 : 베스킨라빈스 31 게임
(1) 많이들 알고있는 바로 그 술자리 게임으로 컴퓨터와의 1:1 대전형식으로 한다. 단, 컴퓨터와 플레이어 모두 31을 초과해서 숫자를 부를 수는 없다.
(2) 위와 규칙은 동일하나 컴퓨터는 항상 자신이 이기도록 나름의 방식의 가지고 숫자를 부른다. 즉, 컴퓨터가 필승하도록 만들어본다.
cf. [수열 입력시 수열의 규칙을 찾아주는 site](http://oeis.org/)  -> 유용하셨다면 ❤️를... 😅👍!

<br>

🍇 **오늘의 수확물** 🍇 : 


- 1) <span style='color:#8A2BE2'>베스킨라빈스 31 게임 필승 전략</span> : [2, 6, 10, 14, 18, 22, 26, 30] 4n+2 수열의 숫자들을 외치는 쪽이 이기게 된다. 따라서, 사실상 먼저 숫자 2를 외치는 쪽이 이기게 된다. 그리고 이것은 반대로 위의 필승 알고리즘으로 만든다해도 유일하게 컴퓨터가 패할 수 있는 경우의 수이다.

>cf. 필승의 해당 수열이 나온 논리에 대해 설명해보자면 내가 30을 외치면 승리! 이므로 내가 마지막 숫자로 30을 외치기 위해선 상대방이 29, 28, 27 중 하나를 마지막 숫자로 외쳐주면 된다. 따라서, 상대방이 외쳐주길 원하는 숫자 3개를 빼면 26이 나오게 되고, 내가 26을 외치면 다음에 다시 내 차례가 될때 30을 외칠 수 있게된다. 이런식으로 생각해보면 필승 숫자 30부터 4씩 감소한다는 것을 알 수 있으며 따라서, 처음 외치면 무조건 이길 수 있게 되는 숫자는 2가 된다. 즉, 필승 숫자 30을 4로 나눈 나머지 값인 2가 필승 숫자를 외칠수 있게 하는 씨앗이된다.

```python
    # 컴퓨터가 몇을 호출할 것인지 호출할 숫자의 범위를 결정하는 것
    # 컴퓨터가 랜덤하게 호출하는 기존의 함수에서 이 if~else 구문만 추가됨
    # 4n+2 수열의 숫자를 불러나가는 쪽이 승리하게되며, 따라서 사실상 먼저 2를 외치는 쪽이 승리할 수 있음
    # 4n n을 4로 나누면 나머지는 0~3이 나올 수 있는데 나누었을 때 나머지 2가 나올 수 있는 숫자는 2를 제외하고는 
    # 전부 필승 수열의 숫자뿐이다. 따라서, 숫자 2를 먼저 외치게 되는 쪽이 승리할 수 있게 된다.
    # 그러므로 last_num % 4 == 2: 인 last_num은 의미가 없다. 1~3 중 몇을 더해도 지기 때문.
    if last_num % 4 == 0:
        call_num_size = 2 # 처음 시작시 2를 먼저 외침
    elif last_num % 4 == 1:
        call_num_size = 1 # 상대가 1을 외치면 1을 추가하여 2를 먼저 외침
    elif last_num % 4 == 3:
        call_num_size = 3 # 상대가 3을 외치면 4n+2 수열의 n=1을 넣은 값인 6을 외치도록 3을 추가함
    else:
        call_num_size = random.randint(1, 3)

    computer_call = [last_num+i for i in range(1, call_num_size+1)]
```

<br>

- 2) <span style='color:#8A2BE2'>턴방식 진행</span> : 교차진행이랄까? 상대턴 -> 내턴 -> 상대턴 이런식으로 번갈아가면서 진행하는 방식을 코드로 구현해보았다.

```python
    if start_player == 'computer' :
        turn = 0 # 역할에 가깝다( 2로 나눈 나머지 값이 0인 숫자들 아무거나 상관없다. 짝수! 단, 그 숫자+1한 숫자를 플레이어의 숫자로 부여해 주어야 한다. 홀수!)
        print('-- 각오해라 휴우먼 --')
    else:
        turn = 1
        print('-- 기계제국으로 돌아가시지 --')
    
    # 첫 시작시 last_num 값을 0으로 초기화 후 진입
    last_num = 0
    
    # 게임의 본체
    while last_num < 31:
        if turn % 2 == 0: # 2로 나눈 나머지 값이 0인 즉, 0(첫번째턴), 2(세번째턴), 4(다섯번째턴) 이런식으로 번갈아 턴을 진행할 수 있게 한다.
            # 두 함수 모두 return 값은 last_num이다.
            # 컴퓨터가 숫자를 호출하는 함수
            last_num = computer_call_number(last_num)
        else:
            # 플레이어가 숫자를 호출하는 함수
            last_num = player_call_number(last_num)

        turn += 1
```


<br>


- 3) <span style='color:#8A2BE2'>리스트 컴프리헨션</span> : 조건 중 마지막에 꼭 31까지 외치도록 하는 조건이 있었다. 따라서, 32 혹은 33을 외치지 않도록 하기위해 리스트 컴프리헨션을 사용하여 32, 33을 리스트에서 코드 한줄로 제거해준다.  (숫자 호출도 리스트로 나란히 나오도록 하기에 이렇게 작성한 것 ex. [1,2] -> [3] -> [4,5,6]])

>cf. 리스트에서 한번에 여러 요소를 제거해 주는 함수는 numpy 패키지의 함수밖에 없다. 따라서, numpy 패키지를 import 하지 않는 이상 이와 같은 방법이 리스트에서 한번에 여러 요소를 지우기에 적합하다고 생각한다.

```python

    # 상대로 부터 받은 마지막 숫자(last_num)에 더해줄 숫자값(i)의 범위를 
    # range(1, 호출할 숫자의 갯수(call_num_size) + 1)를 사용하여 표현한다.
    # 선공인 경우 숫자 0부터 증가가 시작되고, 후공인 경우 상대의 마지막 호출 숫자로부터 증가가 시작된다. 
    # 리스트 컴프리헨션 파이썬 문법을 통해 코드 간소화
    call_list = [last_num+i for i in range(1, call_num_size+1)] 

    # 호출 리스트의 마지막 숫자값
    last_num = call_list[-1]
    
    if last_num >= 31:
        # 리스트 컴프리헨션을 사용하여 마지막 숫자값이 32, 33인 경우는 호출 리스트에서 제외한다. 
        # 이유는 31을 마지막에 꼭 외치도록 하기위해.
        # call_list에서 숫자 하나씩 빼서 item에 넣는데, 그 값이 32, 33이 아닌값만 넣겠다.
        # 그리고 그 item들로 list를 만들겠다.
        call_list = [item for item in call_list if item != 32 and item != 33] 
        print(f'call_list : {call_list}')
```






