>금주의 계획 : 20일 월요일 ~ 22일 수요일 파이썬 게임 프로젝트 진행 / 23일 목요일 ~ 24일 금요일 카카오톡UI클론, 인스타UI클론 프로젝트 진행, 협업을 위한 GIT 활용 특강(오후2시~4시 예정) / 일주일 간 자료구조 알고리즘 강의 듣기, 웹 프로그래밍 A to Z 및 웹 타임어택 과제 복습

<br>

------------------------

<br>


오전 9시 게더타운 대강당에서 금일 오후 4시 전까지 제출해야 하는 간단한 파이썬 게임 프로젝트에 대한 설명을 듣고 프로젝트를 진행하였다.

오늘 진행할 프로젝트는 간단하다고 하기엔 좀 그렇구... 시간이 상당량 소요되는 프로젝트 였고, 어찌어찌 구현은 했지만 알아야 될 사항과 부족했던 부분이 1,2 게임 프로젝트에 비해서 더 많았다.

>[simple Explanation]
파이썬 게임 3 : 간단한 턴방식 RPG 게임
(1) '몬스터', '플레이어'가 각각 존재하고, 모두 <이름/HP/공격력> 이라는 공통속성을 갖는다.
(2) '몬스터'와 '플레이어'는 모두 자신의 턴에 일정한 행동을 할 수 있으며, 단 하나의 행동만을 선택할 수 있다.
(3) '플레이어' 턴 : 특정'몬스터'에게 공격 / 특정'몬스터'에게 마법사용
(4) '몬스터' 턴 : '플레이어'에게 공격 / 자신의 체력을 회복 / 대기
(5) 현재 상황은 '몬스터'와 '플레이어'의 3:1 대치 상황이다.
(6) 위 설명을 기반으로 '플레이어'가 '전사'를 조작하여 3마리의 '몬스터'와 싸우도록 구현한다.

<br>


🍍 **오늘의 수확물** 🍍 : 

(1) <span style='color:gold'>다형성</span> : 여러모양(사전적의미). 프로그래밍 언어의 자료형 체계의 성질을 나타내는 것으로, 프로그램 언어의 각 요소들이 다양한 자료형에 속하는 것이 허가되는 성질. 하나의 객체가 여러 가지 타입을 가질 수 있는 것을 의미. 한마디로 모양은 같은데 다른 기능을 하는 것. 예를 들어, 동일한 스마트폰이라도 통화도 하고, 게임도 하고, 공부도 하는 등 다양하게 사용이 가능하니 다형성이 있다고 할 수 있겠다. 

- 오버라이딩 : 클래스 상속시 부모 클래스에서 정의한 메서드를 자식 클래스에서 재정의하는 것. 단, 부모 클래스에서 정의한 메서드의 기능을 자식 클래스에서 사용할 수 없다. 주로 자식 클래스에서 특정 기능을 바꾸거나 추가하고 싶을때 자주 사용된다.
- 오버로딩 : 동일한 이름의 함수를 매개변수에 따라 여러개 정의하여 각각 다른 기능으로 동작하도록 해준다. 파이썬에선 정식으로 지원되지 않는다. 
cf. 슈퍼 함수(super()) : 부모 클래스 내 메서드를 자식 클래스에서 이용하면서 필요한 부분만 재정의하여 사용할 수 있게 해준다.('super().\[메서드 이름\](매개변수)'로 사용)

>< 참고링크 >
[면접 질문#1](https://velog.io/@dudrbs1040/%EB%A9%B4%EC%A0%91-%EC%A7%88%EB%AC%B81)
[\[Python 입문\] 14.파이썬 오버라이딩과 오버로딩](https://hyeonggi.tistory.com/entry/Python-%EC%9E%85%EB%AC%B8-%EC%98%A4%EB%B2%84%EB%9D%BC%EC%9D%B4%EB%94%A9%EA%B3%BC-%EC%98%A4%EB%B2%84%EB%A1%9C%EB%94%A9)
[파이썬 강좌 – 클래스와 객체 ~ 변수를 사람으로 진화시키기](https://elvanov.com/182)



(2) 전체적인 코드를 올려놓고 <span style='color:gold'>코드 상의 주석</span>을 확인하는 것으로 작성해두겠다.
- 겸허히 알아야 되는 사항과 부족한 부분을 공부하고 코드를 조금씩 수정해 나가야되겠다.


1. 클래스 생성 파트

```python
# 클래스 부분

# [[[ 알아야 될 사항 ]]]
  # 1. 클래스를 만들때 이름이나 체력등을 지정하는게 아니고 인스턴스를 만들때! 비로소 지정하는 것이 맞다.
  # why? 클래스라는 설계도로 수많은 인스턴스를 생성할 수 있을텐데 인스턴스들이 각각 다르게 지정될 수 있기 때문이다.
  # 2. 상속을 받을때는 새로운 속성이 추가되지 않은 이상 __init()__은(생성자는) 사용하지 않는 것이 좋다.
  # why? 부모 클래스의 생성자 속성들이 이미 상속되었는데 생성자 메서드 오버라이딩을 하면 코드 중복 및 부모 클래스의 생성자로 설정해둔 공통 속성에서 어긋날 수 있기 때문이다.
  # 파이썬에서 메서드 오버라이딩시, 부모 클래스에서 정의한 메서드의 기능을 자식 클래스에서 재활용이 불가능하다.

class Object:
    def __init__(self, name, hp, physical_pow):
        self.name = name
        self.hp = hp
        self.physical_pow = physical_pow
        print(f'{self.name} 이(가) 생성 되었습니다.')
        print(f'체력 : {self.hp}, 물리 공격력 : {self.physical_pow}')
    
    def attack(self, target):
        print(f'{self.name}가 {target.name}을 {self.physical_pow}의 물리 공격력으로 공격했습니다.')
        target.hp -= self.physical_pow # target_hp - 자신 공격력 = target의 남은 hp!
        # 심화 개념: 사실은 여기서 target.hp 를 할당한다고 해서 실제로 해당 target 의 hp 값이 바뀌면 안되는 것이 원칙.
        # 그러므로 함수 마지막에서 return target.hp 를 해서 해당 target 의 값에 재할당해주는 것이 맞음.
        # 그러나 파이썬의 경우 자동으로 target이 가진 속성의 주소를 변경해주기에, 
        # 굳이 재할당해주지 않아도, 해당 target 의 hp 값이 바뀜.
        return target.hp # 재할당 해줌.

    def status(self):
        if self.hp > 0:
          print(f'{self.name}의 체력 : {self.hp}')


class Player(Object):
    def __init__(self,  name, hp, physical_pow, magic_pow=50):
        Object.__init__(self, name, hp, physical_pow)
        self.magic_pow = magic_pow

    def magic_attack(self, target):
        print(f'{self.name}가 {target.name}을 {self.magic_pow}의 마법 공격력으로 공격했습니다.')
        target.hp -= self.magic_pow
        return target.hp


class Monster(Object):
    def cure(self):
        # 여기서 생각해 볼 수 있는것은 max_hp 설정해놓고 그 이상 회복 못하게끔 제한하는 것.
        self.hp += 10
        print(f'{self.name}가 자신의 체력을 10만큼 회복했습니다. 현재 체력 : {self.hp}')
        return self.hp

    def wait(self):  
        print(f'{self.name}가 대기했습니다.')
```

<br>

2. 함수 생성 파트

```python
# 함수 부분

# [[[ 알아야 될 사항 ]]]
# 1. player_action(Player, Monsters) 이런식으로 다양한 인스턴스에 대처할 수 있도록 큰 범주가 공통적인 인자로 지정해주는게 좋다!
# 2. 함수별로 return을 잘 작성해줘야한다! > 중복 참조 인자가 외부에 있을경우에 문제발생 시 대처가 어려워질 수 있기때문

def player_action():
    print('< 공격 스킬 선택 phase >')
    print('1. 물리 공격')
    print('2. 마법 공격')
    p1_skill_input = int(input('사용할 스킬의 번호를 입력하세요. : '))

    print('< 대상 선택 phase >')
    print('1.고블린')
    print('2.오크')
    print('3.빅보스 Waaah')
    p1_target_input = int(input('공격할 대상의 번호를 입력하세요. : '))

# <<< 부족했던 부분 >>>
# 1. 대상 지정을 숫자로 일일히 한 것.
# 2. 생성한 대상들이 리스트나 딕셔너리로 묶여 있어야 한번에 표시하기 쉬워진다.
# 3. 딕셔너리로 묶여 있을 경우 키값으로 찾는 형식이 가능해지기에 더 직관적이게 된다.
# 한마디로 아래와 같이 작성시 수많은 인스턴스의 파도가 칠때 답이 없어진다.

    # 물리 공격시
    if p1_skill_input == 1:
        # 공격 대상 고블린
        if p1_target_input == 1:
            m1.hp = p1.attack(m1)
        # 공격 대상 오크
        elif p1_target_input == 2:
            m2.hp = p1.attack(m2)
        # 공격 대상 빅보스 Waaah
        elif p1_target_input == 3:
            m3.hp = p1.attack(m3)
    # 마법 공격시
    elif p1_skill_input == 2:
        # 공격 대상 고블린
        if p1_target_input == 1:
            m1.hp = p1.magic_attack(m1)
        # 공격 대상 오크
        elif p1_target_input == 2:
            m2.hp = p1.magic_attack(m2)
        # 공격 대상 빅보스 Waaah
        elif p1_target_input == 3:
            m3.hp = p1.magic_attack(m3)

def monster_action():
    # 살아있는 몬스터들만 행동
        if m1 in mon_list:
            # 고블린 행동
            action_num = rd.randint(1, 3) # 행동 번호 결정
            if action_num == 1: # 자신 치유
                m1.cure()
            elif action_num == 2: # 대기
                m1.wait()
            elif action_num == 3: # 플레이어 공격
                p1.hp = m1.attack(p1)
        if m2 in mon_list:
            # 오크 행동
            action_num = rd.randint(1, 3)
            if action_num == 1:
                m2.cure()
            elif action_num == 2:
                m2.wait()
            elif action_num == 3:
                p1.hp = m2.attack(p1)
        if m3 in mon_list:
            # 빅보스 Waaah 행동
            action_num = rd.randint(1, 3)
            if action_num == 1:
                m3.cure()
            elif action_num == 2:
                m3.wait()
            elif action_num == 3:
                p1.hp = m3.attack(p1)

# 공격 종료 후 몬스터들 죽음상태 체크
# 이 부분에서도 리스트에서 제거하는것이 아닌 hp가 0인 죽음 상태에서 리스트에 존재하도록 하는게 더 나을것으로 생각된다.
# 환생 등 고려 가능
def monster_death():
    if m1.hp <= 0: # 고블린 hp가 0 이하이면
        if m1 in mon_list: # 몬스터 리스트에 고블린 요소가 존재하면
            mon_list.remove(m1) # 몬스터 리스트에서 고블린 요소 제거
    if m2.hp <= 0:
        if m2 in mon_list:
            mon_list.remove(m2)
    if m3.hp <= 0:
        if m3 in mon_list:
            mon_list.remove(m3)
```

<br>


3. 게임 실행 파트

```python
# 게임 실행 부분

import random as rd

# <<< 부족했던 부분 >>>
# 1. 만약 플레이어나 몬스터의 숫자가 훨씬 많았다면 이렇게 작성해서는 택도 없다. 
# 루프를 돌리면서 리스트 혹은 딕셔너리에 저장하는것이 맞겠다.

p1 = Player('워리어', 100, 10)
m1 = Monster('고블린', 10, 10)
m2 = Monster('오크', 30, 30)
m3 = Monster('빅보스 Waaah', 50, 50)

mon_list = [m1, m2, m3]

turn = 0

while True:

    # 턴 시작전 총 상태표시
    print('===== 턴 시작전 총 상태표시 =====')
    p1.status() # 플레이어
    for m in mon_list: # 몬스터들
        m.status()


    # 플레이어 턴
    if turn % 2 == 0:
        print('===== 플레이어 턴 =====')
        
        # 플레이어 액션
        player_action()

        # 몬스터 사망 여부 체크
        monster_death()

        # 몬스터 리스트에 몬스터가 없을 경우
        if len(mon_list) <= 0:
            print('모든 몬스터를 물리쳤습니다!')
            print('===== Win! =====')
            break


    # 몬스터 턴
    else:
        print('===== 몬스터 턴 =====')
        
        # 몬스터 액션
        monster_action()

        # 공격 종료 후 플레이어 상태 체크
        if p1.hp <= 0:
            print('플레이어 사망!')
            print('== Game Over ==')
            break

    turn += 1
    print('-------------------')
    print('----- 턴 종료 -----')
    print('-------------------')
```
